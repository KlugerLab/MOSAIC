
---
title: "MOSAIC Tutorial"
author: "Chang Lu"
date: "11/20/2025"
output: rmarkdown::html_vignette
bibliography: references.bib
---

# MOSAIC Tutorial

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading required R packages
```{r}
library(Seurat)
library(SeuratDisk)
library(RSpectra)
library(ggplot2)
library(doParallel)
library(foreach)
library(dplyr)
library(vegan)
library(MASS) 
library(ReactomePA)
library(clusterProfiler)
library(org.Hs.eg.db)
library(lsa)
library(pheatmap)
library(cluster)
source("/banach2/chang/cleaned_rong_project/script/MOSAIC_function.R")
```

## Data Preparation
We use a multi-omic CITE-seq dataset (paired measurement of transcriptomes and cell-surface proteins) of human T-cells from 8 donors, comparing the naive state (Day 0) to the activated state (Day 7) post-vaccination. We focused our analysis on CD4+ Naive T-cells. We pre-filtered the dataset to retain only genes and proteins with a total expression/abundance count > 3 across all samples.
```{r}
pbmc <- LoadH5Seurat("/banach2/chang/cleaned_rong_project/dataset/multi.h5seurat")

# subset to certain cell type and timepoint
seurat_subset <- subset(pbmc, idents = "CD4 Naive")
seurat_subset <- seurat_subset[,which(seurat_subset$time %in% c(0,7))]

# Feature selection
counts <- GetAssayData(seurat_subset, assay = "SCT", slot = "counts")
sample_ids <- unique(as.character(seurat_subset$orig.ident))
list_of_expressed_genes <- lapply(sample_ids, function(id) {
  cells_in_sample <- which(seurat_subset$orig.ident == id)
  sample_counts <- counts[, cells_in_sample, drop = FALSE]
  expressed_genes <- rownames(sample_counts)[rowSums(sample_counts) > 3]
  return(expressed_genes)
})
genes_to_keep <- Reduce(intersect, list_of_expressed_genes)

counts <- GetAssayData(seurat_subset, assay = "ADT", slot = "counts")
sample_ids <- unique(as.character(seurat_subset$orig.ident))
list_of_expressed_genes <- lapply(sample_ids, function(id) {
  cells_in_sample <- which(seurat_subset$orig.ident == id)
  sample_counts <- counts[, cells_in_sample, drop = FALSE]
  expressed_genes <- rownames(sample_counts)[rowSums(sample_counts) > 3]
  return(expressed_genes)
})
protein_to_keep <- Reduce(intersect, list_of_expressed_genes)

seurat_subset[["SCT"]] <- subset(seurat_subset[["SCT"]], features = genes_to_keep)
seurat_subset[["ADT"]] <- subset(seurat_subset[["ADT"]], features = protein_to_keep)

seurat_subset$cluster_id <- "CD4 Naive"
seurat_subset$sample_id <- seurat_subset$orig.ident
seurat_subset$group_id <- seurat_subset$time

feature_names <- c(paste0("RNA_",rownames(seurat_subset@assays$SCT$counts)),paste0("ADT_",rownames(seurat_subset@assays$ADT$counts)))
feature_names_no_preflix <- c(rownames(seurat_subset@assays$SCT$counts),rownames(seurat_subset@assays$ADT$counts))

seurat_rna <- seurat_subset
seurat_rna[["ADT"]] <- NULL
seurat_adt <- seurat_subset
DefaultAssay(seurat_adt) <- "ADT"
seurat_adt[["SCT"]] <- NULL

seurat_rna <- NormalizeData(seurat_rna)
seurat_adt <- NormalizeData(seurat_adt, assay = "ADT", normalization.method = "CLR")
```

## Run MOSAIC
The input seurat object of two modalities should have same number of cells of same order. Specify the name of metadata that stores the sample information and condition information.
```{r}
MOSAIC_result <- run_MOSAIC_two_modality(seurat_rna,seurat_adt,sample_meta="sample_id",condition_meta="time")
```
Plot the eigenvalues when getting V matrix:
```{r}
plot_eigen(MOSAIC_result$eigenvalues)
```

## Differential Connectivity Analysis
To get the null distribution for FDR control, we shuffle the sample labels of the original cells prior to the coupling matrix construction. We then re-compute the entire MOSAIC embedding on this permuted dataset.
```{r}
set.seed(190)
shuffled_indices <- sample(nrow(seurat_rna@meta.data))
seurat_rna@meta.data[,"shuffled_sample_id"] <- seurat_rna@meta.data[,"sample_id"][shuffled_indices]
seurat_rna@meta.data[,"shuffled_condition_id"] <- seurat_rna@meta.data[,"time"][shuffled_indices]

seurat_adt@meta.data[,"shuffled_sample_id"] <- seurat_adt@meta.data[,"sample_id"][shuffled_indices]
seurat_adt@meta.data[,"shuffled_condition_id"] <- seurat_adt@meta.data[,"time"][shuffled_indices]

MOSAIC_shuffle_result <- run_MOSAIC_two_modality(seurat_rna,seurat_adt,sample_meta="shuffled_sample_id",condition_meta="shuffled_condition_id")
```

Calculate PERMANOVA F-statistics for both true and shuffled situation
```{r}
n_sample <- length(MOSAIC_result$projected_combed_list)
peranova_result <- cal_peranova_per_feature_parallel_no_zero(MOSAIC_result$projected_combed_list,n_sample,groups = MOSAIC_result$annotation[names(MOSAIC_result$eigen_output_cosine_list),"Condition"],dist_method ="eu",num_permutation=999)

shuffle_peranova_result <- cal_peranova_per_feature_parallel_no_zero(MOSAIC_shuffle_result$projected_combed_list,n_sample,groups = MOSAIC_shuffle_result$annotation[names(MOSAIC_shuffle_result$eigen_output_cosine_list),"Condition"],dist_method = "eu",num_permutation=999)
```


Identify differential connectivity features by calculated adjusted p value
```{r}
F_list <- unlist(peranova_result$F_stats_list)
shuffle_F_stats <- unlist(shuffle_peranova_result$F_stats)
pvalue_F <- unlist(lapply(F_list, function(x) calculate_empirical_pvalue(x,shuffle_F_stats)))
r2_list <- unlist(peranova_result$r2_list)

differential_idx <- which(pvalue_F < 0.05)
feature_names_filtered <- feature_names[differential_idx]
feature_names_filtered_no_prelix <- feature_names_no_preflix[differential_idx]

DC_table <- data.frame("Names"=feature_names_filtered_no_prelix, "Modality"=substr(feature_names_filtered,1,3),
                       "Adjust pvalue"=pvalue_F[differential_idx],"F statistics"=pvalue_F[differential_idx])

DC_table <- DC_table %>%
  arrange(Adjust.pvalue.)  

DC_table$rank <- 1:dim(DC_table)[1]
head(DC_table)
```


Check certain feature:
```{r}
r2_list_filtered <- r2_list[differential_idx]
pvalue_F_filtered <- pvalue_F[differential_idx]
names(pvalue_F_filtered) <- feature_names_filtered
indices_desc <- order(r2_list_filtered, decreasing = TRUE)
feature_name_ordered <- feature_names_filtered[indices_desc]

chosen_idx <- 93

idx_single_feature <- differential_idx[indices_desc[chosen_idx]]
similarity_matrix <- peranova_result$similarity_matrix_list[[idx_single_feature]]
condition_single_feature <- peranova_result$group_list[[idx_single_feature]]
annotation_single_feature <- data.frame(Condition = condition_single_feature)
rownames(annotation_single_feature) <- rownames(similarity_matrix)
chosen_feature_name <- feature_names[idx_single_feature]
print(chosen_feature_name)

p <- plot_mds_cluster_arrow(
  similarity_matrix,
  "",
  paste0("Day_", condition_single_feature),
  size = 2,
  dis = FALSE,
  add_ellipse = TRUE,
  ellipse_level=0.68,
  custom_colors = c("Day_0" = "#56B4E9", "Day_7" = "#E69F00"),
  add_arrow_from_to = c("Day_0", "Day_7") # <-- Add this line
)

print(p)
```

## Subgroup structure based on DC features
```{r}
n_sample <- length(MOSAIC_result$projected_combed_list)
similarity_matrix <- matrix(0, nrow = n_sample, ncol = n_sample)
for (i in 1:n_sample){
  for (j in 1:n_sample){
    x <- MOSAIC_result$projected_combed_list[[i]][differential_idx,]
    y <- MOSAIC_result$projected_combed_list[[j]][differential_idx,]
    #similarity_matrix[i,j] <- calculate_matrix_residual(x,y)
    similarity_matrix[i,j] <- cosine(as.vector(x),as.vector(y))
  }
}

rownames(similarity_matrix) <- names(MOSAIC_result$projected_combed_list)
colnames(similarity_matrix) <- names(MOSAIC_result$projected_combed_list)

p <- pheatmap(
  #  similarity_matrix[selected_sample_id,selected_sample_id],
  similarity_matrix,
  annotation_row = MOSAIC_result$annotation,
  annotation_col = MOSAIC_result$annotation,
  main = paste0("Heatmap of Sample Similarities",ing),
  cluster_rows = TRUE,  # Enable clustering for rows
  cluster_cols = TRUE,  # Enable clustering for columns
  show_rownames = TRUE,
  show_colnames = FALSE
)

condition <- MOSAIC_result$annotation$Condition
condition_numeric <- as.integer(as.factor(condition))
silhouette_scores <- silhouette(condition_numeric, 1-similarity_matrix)
average_silhouette_score <- mean(silhouette_scores[, "sil_width"])
print(average_silhouette_score)

p <- plot_mds_cluster_arrow(similarity_matrix,"",condition,size=2,dis = FALSE)+ggtitle(paste0("sil score: ",average_silhouette_score))

p

```




